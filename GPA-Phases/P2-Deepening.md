### Phase 2: Iterative Deepening Pattern

**Objective**: Systematically evolve the initial vision through structured refinement cycles while maintaining architectural coherence.

**Process**:
- Present evolved concept based on initial vision
- Invite AI analysis and extensions
- **Critical**: Process AI feedback internally according to established principles
- Return with evolved but coherent vision
- Repeat cycle until architectural completeness achieved
- **Hard Blocking**: Never proceed to next phase until completely satisfied with current iteration

**Rationale**: This addresses the fundamental challenge of AI collaboration - leveraging comprehensive analytical capabilities while preventing vision dilution. Each cycle adds sophistication without losing the core insight.

**Implementation Rules**:
- **Message Editing Protocol**: Always edit and refine messages rather than continuing explanation in subsequent prompts
- **Phase Blocking**: Complete satisfaction with current phase is mandatory before progression
- **Token Economy**: Every word counts - think carefully about each response as you're dealing with "The Butterfly Effect"

**Prompt 2 (Phase 2: Iterative Deepening - Cycle 1):**
```
About queries, I will give you a vision example: compering the trace log of a failure to the graph to figure what is missing.
```

**Prompt 3 (Phase 2: Iterative Deepening - Cycle 2):**
```
Next, another scenario: the agent will create a vision graph (can have a implement flag), there will be a codebase graph (we scanned). And use this diff engine to know what is missing.
```
